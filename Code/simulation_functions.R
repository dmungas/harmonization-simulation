
# equateSim is a function the uses R mirt item response theory (IRT) methods
# to: 1) simulate item level datasets based on item parameters, 2) perform IRT
# calibrations on the simulated datasets, 3) estimate ability scores for each
# person in the simulated datasets, and 4) compute metrics to quantify the 
# correspondence between the estimated ability from the simulated datasets and the 
# true ability that was used to generate the simulations. Metrics include the
# root mean square error (RMSE), the mean of the estimated ability scores, and
# the standard deviation of the estimated ability scores. Multiple simulations 
# of the same set of simulated true ability values can be generated (n_rep_theta).
#   This function simulates two groups that can differ in mean and standard
# deviation of simulated true ability, and different items can be used for each
# group as long as there is at least one common, linking item.
# 
# Parameters:
#   seed - random seed for simulations (default=NULL)
#   grp_mean - true ability means of the two groups (default=c(0.5,-0.5))
#   grp_sd - true ability standard deviations of the two groups (default=c(1,1))
#   n_rep - number of simulated samples of true ability values (default=100)
#   n_rep_theta - number of repetitions of each simulated sample of true ability 
#     values (default=1)
#   n_samp - sample size of each group in each simulation (default=500)
#   n_itm - number of items (default=30)
#   pars - mirt item parameters file (default=mcal_par)
#     A parameter file can be generated by:
#       mcal_par <- mirt(df,mdl,pars='values') where df is a dataframe with
#         item response data and mdl is a mirt model object. The returned file 
#         (mcal_par in this example) can be edited to change item parameters.
#   n_rep - number of simulated samples of true ability values (default=100)
#   itms1 - list of items available for group 1 (default=item_list_1)
#   itms2 - list of items available for group 2 (default=item_list_2)
#   fsc_method - mirt method for calculating estimated ability values 
#     (default="EAP")
#   mod_res_obj - mirt model results object from mirt analysis. This must
#     be from the same mirt model as pars.
#   save_sims - option to output simulated datasets (default=FALSE)

# equateSim returns a list with 2 elements:
# 1. "summary" - a dataframe that has summary statistics (rmse, mean
# estimated ability, sd estimated ability) for each group and each simulated
# sample of true abilities (n_rep). These statistics are produced for raw
# estimated abilities and for estimated abilities on a metric transformed to
# match the true ability metric.
# 2. "datasets" (if save_sims=TRUE) - a long format dataframe that includes original and estimated
# theta scores, group assignment, sample number, and rep_theta number 

equateSim <- function(seed=NULL,grp_mean=c(0.5,-0.5),grp_sd=c(1,1),
      n_samp=500,n_rep_theta=1,n_itm=30,pars=mcal_pars,n_rep=100,
      itms1=item_list_1,itms2=item_list_2,fsc_method="EAP",
      mod_res_obj=NULL,save_sims=FALSE) {
  require(dplyr)
  require(tidyr)
  require(mirt)
  extractDiffMatrix <- function(pars){
    diff1 <- pars[grepl("d+",pars$name),c("item","name","value")]
    diff1$item <- as.character(diff1$item)
    diffsum <- diff1 %>% group_by(item) %>% summarise(
      ncat = sum(!is.na(item))
    )
    diff <- matrix(nrow=nrow(diffsum),ncol=max(diffsum$ncat))
    for (j in 1:nrow(diffsum)) {
      vals <- diff1[diff1$item %in% diffsum[j,"item"],"value"]
      if(length(vals) < max(diffsum$ncat)){
        for (i in (length(vals)+1):max(diffsum$ncat)){
          vals[i] <- NA
        }
      }
      diff[j,] <- vals
    }
    return(diff)
  }
  # extractParameters is not currently used
  # extractParameters <- function(mod_res_obj,pars) {
  #   parests <- data.frame(coef(mod_res_obj,as.data.frame=TRUE))
  #   parests$label <- row.names(parests)
  #   parests <- parests %>% separate(label,c("item","name"),extra = "merge", fill = "left")
  #   pars2 <- merge(pars,parests,by=c("item","name"),all.x=TRUE)
  #   pars2$value <- ifelse(!is.na(pars2$par),pars2$par,pars2$value)
  #   pars2 <- pars2[,!names(pars2) %in% "par"]
  #   pars2 <- pars2[order(pars2$parnum),]
  #   return(pars2)
  # }
  # if (!is.null(mod_res_obj)) {
  #   pars <- extractParameters(mod_res_obj,pars)
  # }
  diff <- extractDiffMatrix(pars)
  disc <- pars[pars$name == "a1","value"]
  itemtype <- as.character(pars[pars$name =="a1","class"])
  model <- mirt.model(paste("cog = 1-",n_itm,sep=""))
  set.seed(seed)
  j <- 0
  while (j < n_rep) {
    j <- j+1
    time <- Sys.time()
    theta1 <- data.frame(rnorm(n_samp,grp_mean[1],grp_sd[1]))
    names(theta1) <- "theta1"
    theta1$group <- 1
    theta2 <- data.frame(rnorm(n_samp,grp_mean[2],grp_sd[2]))
    names(theta2) <- "theta1"
    theta2$group <- 2
    theta1 <- rbind(theta1,theta2)
    
    
    #   hist(theta1)
    
    ds <- list()
    for (i in 1:n_rep_theta){
      if (is.null(mod_res_obj)) {
        ds2 <- data.frame(simdata(a=disc,d=diff,N=n_samp,Theta=as.matrix(theta1$theta1),
          itemtype=itemtype))
      } else {
        ds2 <- data.frame(simdata(model=mod_res_obj,N=n_samp,
          Theta=as.matrix(theta1$theta1)))
      }
 
      names(ds2) <- unique(pars[!pars$item == "GROUP","item"])
      # ds2[1:n_samp,"group"] <- 1
      # ds2[(n_samp+1):nrow(ds2),"group"] <- 2
      # ds2 <- sim.poly.npn(nvar = 30 ,n = 500, a=discr,
      #                     c=0,z=1,d=diff, mu=0, sd=1, cat=2,theta=theta1)
      # ds2 <- sim.poly.npn(nvar = 30 ,n = 500, a=discr,
      #     c=0,z=1,d=diff1, mu=0, sd=1, cat=2,theta=theta1)
      
      ds2 <- cbind(theta1,ds2)
      
      for(group in 1:2) {
        if (group == 1) {
          ds2[ds2$group == 1,!names(ds2) %in% c("theta1","group",itms1)] <- NA
        } else {
          ds2[ds2$group == 2,!names(ds2) %in% c("theta1","group",itms2)] <- NA
        }
      }
      ds[[i]] <- ds2
    }

    sim_summ <- list()
    dataset <- list()
    for (i in 1:length(ds)){
      # capture errors due to not all response option occurring in simulated dataset
      pars1 <- tryCatch({
        mirt(ds[[i]][,3:(n_itm+2)],model=model,pars='values')
        }, warning = function(w){
          return("warning")
        }, error = function(e){
          return("error")
        })
      if(!pars1 %in% c("error","warning")) {
        mcal <- mirt(ds[[i]][,3:(n_itm+2)],model=model,pars=pars1)
        # mcal <- mirt(ds[[i]][,3:(n_itm+2)],model,itemtype='2PL',pars=pars)
        #   coef(mcal)
        # mod_res_obj@Data$model
        
        # if (fsc_method=="EAP") {
        #   fsc <- fscores(mcal,full.scores=TRUE, method="EAP")
        #   t6 <- cbind(ds[[i]],fsc)
        #   names(t6) <- sub("F1","ability_est",names(t6))
        #   names(t6) <- sub("theta1","ability",names(t6))
        # } else {
        #   fsc <- fscores(mcal,full.scores=TRUE, plausible.type="MH",plausible.draws=50)
        #   fsc_med <- data.frame(list(fsc[[5]],fsc[[10]],fsc[[15]],fsc[[20]],fsc[[25]],fsc[[30]],fsc[[35]],
        #                              fsc[[40]],fsc[[45]],fsc[[50]]))
        #   names(fsc_med) <- c("D1","D2","D3","D4","D5","D6","D7","D8","D9","D10")
        #   fsc_med$ability_est <- apply(fsc_med,1,median)
        #   
        #   t6 <- cbind(ds[[i]],fsc_med)
        #   names(t6) <- sub("theta1","ability",names(t6))
        # }
        
        fsc <- data.frame(fscores(mcal,full.scores=TRUE, method=fsc_method))
        names(fsc) <- "ability_est"
        t6 <- cbind(ds[[i]],fsc)
        # names(t6) <- sub("F1","ability_est",names(t6))
        names(t6) <- sub("theta1","ability",names(t6))
        
        t6$ability_est <- ifelse(t6$ability_est %in% c(Inf,-Inf),NA,t6$ability_est)
        
        t6$resid <- t6$ability_est - t6$ability
        
        t6$abil_est_st <- (t6$ability_est - mean(t6$ability_est,na.rm=TRUE))*
          (sd(t6$ability)/sd(t6$ability_est,na.rm=TRUE)) +
          mean(t6$ability) # linear equating to true ability metric
        
        t6$resid_st <- t6$abil_est_st - t6$ability
        t6$sample <- j
        t6$rep_theta <- i
        
        # plot(t6$resid ~ t6$ability)
        
        sim_summ[[i]] <- t6[,c("ability","ability_est","resid","abil_est_st","resid_st","group")]
        
        if (save_sims == TRUE) {
          if (j==1 & i == 1) {
            sim_data <- t6
          } else {
            sim_data <- rbind(sim_data,t6)
          }
        }
        
      } else {
        j <- j-1
      }
    }
    ### This code block can be modified to output true ability, estimated
    #   ability, and simulated datasets
    # abil <- data.frame(matrix(ncol = length(sim_summ), nrow = 500))
    # abil_est <- data.frame(matrix(ncol = length(sim_summ), nrow = 500))
    # res <- data.frame(matrix(ncol = length(sim_summ), nrow = 500))
    stat <- data.frame(matrix(nrow = 12,ncol = length(sim_summ)))
    if (length(sim_summ) > 0) {
      for (i in 1:length(sim_summ)) {
        nm <- paste("dset_",i,sep="")
        # abil[,i] <- sim_summ[[i]]$ability
        # names(abil)[i] <- nm
        # abil_est[,i] <- sim_summ[[i]]$abil_est_st
        # names(abil_est)[i] <- nm
        # res[,i] <- sim_summ[[i]]$resid_st
        # names(res)[i] <- nm
        df <- sim_summ[[i]]
        stat[1,i] <- sqrt(mean(df[df$group==1,"resid"]^2,na.rm=TRUE))
        stat[2,i] <- sqrt(mean(df[df$group==2,"resid"]^2,na.rm=TRUE))
        stat[3,i] <- sqrt(mean(df[df$group==1,"resid_st"]^2,na.rm=TRUE))
        stat[4,i] <- sqrt(mean(df[df$group==2,"resid_st"]^2,na.rm=TRUE))
        stat[5,i] <- mean(df[df$group==1,"ability_est"],na.rm=TRUE)
        stat[6,i] <- mean(df[df$group==2,"ability_est"],na.rm=TRUE)
        stat[7,i] <- mean(df[df$group==1,"abil_est_st"],na.rm=TRUE)
        stat[8,i] <- mean(df[df$group==2,"abil_est_st"],na.rm=TRUE)
        stat[9,i] <- sd(df[df$group==1,"ability_est"],na.rm=TRUE)
        stat[10,i] <- sd(df[df$group==2,"ability_est"],na.rm=TRUE)
        stat[11,i] <- sd(df[df$group==1,"abil_est_st"],na.rm=TRUE)
        stat[12,i] <- sd(df[df$group==2,"abil_est_st"],na.rm=TRUE)
        names(stat)[i] <- nm
        stat[c(1,3,5,7,9,11),"group"] <- 1
        stat[c(2,4,6,8,10,12),"group"] <- 2
        stat[c(1,2,5,6,9,10),"type"] <- "raw"
        stat[c(3,4,7,8,11,12),"type"] <- "standardized"
        stat[c(1:4),"statistic"] <- "rmse"
        stat[c(5:8),"statistic"] <- "est_mean"
        stat[c(9:12),"statistic"] <- "est_sd"
        stat$samp_num <- j
      } # end for i
    }
    if (j>0) {
      if (j==1) {
        stat_summ <- stat
      } else {
        stat_summ <- rbind(stat_summ,stat)
      }
    }
    cat(paste("  Iteration - ",j,", Elapsed time: ",Sys.time() - time,"\n",sep=""))
  } # end for j
  if(n_rep_theta == 1){
    stat_summ$avg <- stat_summ$dset_1
  } else {
    stat_summ$avg <- apply(stat_summ[,1:n_rep],1,mean)
  }
  sim_results <- list()
  sim_results[["summary"]] <- stat_summ
  if (save_sims == TRUE) {
    vnms <- c("ability","ability_est","resid","abil_est_st","resid_st",
        "group","sample","rep_theta")
    itnms <- names(sim_data[!names(sim_data) %in% vnms])
    sim_results[["datasets"]] <- sim_data[,c(vnms,itnms)]
  } 
  return(sim_results)
}


# infoSim is a function that uses R mirt item response theory (IRT) methods
# to: 1) simulate an item level dataset based on item parameters, 2) perform an IRT
# calibrations on the simulated dataset, and 3) calculate test information values
# across a range of ability values. It estimates test innformation for two group 
# that can have different distributions of ability, and different items can be 
# used for the two groups.

# Parameters:
#   seed - random seed for simulations (default=NULL)
#   grp_mean - true ability means of the two groups (default=c(0.5,-0.5))
#   grp_sd - true ability standard deviations of the two groups (default=c(1,1))
#   n_samp - sample size of each group in each simulation (default=500)
#   pars - mirt item parameters file (default=mcal_par)
#     A parameter file can be generated by:
# #       mcal_par <- mirt(df,mdl,pars='values') where df is a dataframe with
# #         item response data and mdl is a mirt model object. The returned file 
# #         (mcal_par in this example) can be edited to change item parameters.
# #   itms1 - list of items available for group 1 (default=item_list_1)
# #   itms2 - list of items available for group 2 (default=item_list_2)
# This function returns a dataframe with ability values and corresponding test 
# information values. This dataset can be use to graph a test information curve.

infoSim <- function(seed=NULL,grp_mean=c(0.5,-0.5),grp_sd=c(1,1),
      n_samp=500,pars=mcal_par,itms1=item_list_1,itms2=item_list_2) {
  diff <- pars[pars$name == "d","value"]
  disc <- pars[pars$name == "a1","value"]
  n_itm <- nrow(pars[pars$name == 'a1',])
  links <- intersect(itms1,itms2)
  set.seed(seed)
  
  theta1 <- data.frame(rnorm(n_samp,grp_mean[1],grp_sd[1]))
  names(theta1) <- "theta1"
  theta1$group <- 1
  theta2 <- data.frame(rnorm(n_samp,grp_mean[2],grp_sd[2]))
  names(theta2) <- "theta1"
  theta2$group <- 2
  theta1 <- rbind(theta1,theta2)
  
  ds <- data.frame(simdata(disc, diff, n_samp, Theta=as.matrix(theta1$theta1),
                           itemtype = '2PL'))
  names(ds) <- unique(pars[!pars$item == "GROUP","item"])
  ds <- cbind(theta1,ds)
  
  for(group in 1:2) {
    if (group == 1) {
      ds[ds$group == 1,!names(ds) %in% c("theta1","group",itms1)] <- NA
    } else {
      ds[ds$group == 2,!names(ds) %in% c("theta1","group",itms2)] <- NA
    }
  }
  
  pars1 <- pars[pars$item %in% c(itms1,"GROUP"),]
  pars1$parnum <- 1:nrow(pars1)
  pars1[pars1$name=="d" & !pars1$item %in% links,"est"] <- TRUE
  pars1[pars1$name=="a1" & !pars1$item %in% links,"est"] <- TRUE
  
  pars2 <- pars[pars$item %in% c(itms2,"GROUP"),]
  pars2$parnum <- 1:nrow(pars2)
  pars2[pars2$name=="d" & !pars2$item %in% links,"est"] <- TRUE
  pars2[pars2$name=="a1" & !pars2$item %in% links,"est"] <- TRUE
  
  n_itm_1 <- nrow(pars1[pars1$name == 'a1',])
  n_itm_2 <- nrow(pars2[pars2$name == 'a1',])
  
  mdl1 <- mirt.model(paste("cog = 1-",n_itm_1,sep=""))
  mdl2 <- mirt.model(paste("cog = 1-",n_itm_2,sep=""))
  
  
  Theta <- matrix(seq(-4,4, by = .1))
  
  mcal1 <- mirt(ds[ds$group %in% 1,names(ds) %in% itms1],model=mdl1,
                modelitemtype='2PL',pars=pars1)
  mcal2 <- mirt(ds[ds$group %in% 2,names(ds) %in% itms2],model=mdl2,
                modelitemtype='2PL',pars=pars2)
  tinfo1 <- testinfo(mcal1,Theta)
  tinfo2 <- testinfo(mcal2,Theta)
  tinfo <- data.frame(cbind(Theta,tinfo1,tinfo2))
  names(tinfo) <- c("ability","info_1","info_2")
  
  return(tinfo)
}

# infoCalc is a function that generates test information values for a range of 
# abilities based on a mirt results object (mirt_model_obj). It returns a 
# dataframe with ability values and corresponding test information values. 
# This dataset can be use to graph a test information curve.

infoCalc <- function(mirt_mod_obj) {
  theta <- matrix(seq(-4,4, by = .1))
  tinfo <- testinfo(mirt_mod_obj,theta)
  tinfo <- data.frame(cbind(theta,tinfo))
  names(tinfo) <- c("ability","information")
  
  return(tinfo)
}

# summaryStats is a function that calculates means across simulated datasets 
# of summary statistics (rmse, rmse_st, mean, mean_st, sd sd_st) returned by 
# equateSim.
# 
# Parameters:
#   df - data.frame of summary statistics for each simulated dataset returned
#     by equateSim
#     
# summaryStats returns a dataframe withthe means across simulated datasets of 
# rmse, rmse_st, mean, mean_st, and sd sd_st for each group as well as the 
# simple average of both groups. It includes a group variable (Group 1,
# Group 2, Combined) 

summaryStats <- function(df) {
  rmse_grp_1 <- mean(df[df$group == 1 & df$type == "raw" & 
      df$statistic == "rmse","avg"])
  rmse_grp_2 <- mean(df[df$group == 2 & df$type == "raw" & 
      df$statistic == "rmse","avg"])
  rmse_st_grp_1 <- mean(df[df$group == 1 & df$type == "standardized" & 
      df$statistic == "rmse","avg"])
  rmse_st_grp_2 <- mean(df[df$group == 2 & df$type == "standardized" & 
      df$statistic == "rmse","avg"])
  mean_grp_1 <- mean(df[df$group == 1 & df$type == "raw" & 
      df$statistic == "est_mean","avg"])
  mean_grp_2 <- mean(df[df$group == 2 & df$type == "raw" & 
      df$statistic == "est_mean","avg"])
  mean_st_grp_1 <- mean(df[df$group == 1 & df$type == "standardized" & 
      df$statistic == "est_mean","avg"])
  mean_st_grp_2 <- mean(df[df$group == 2 & df$type == "standardized" & 
      df$statistic == "est_mean","avg"])
  sd_grp_1 <- mean(df[df$group == 1 & df$type == "raw" & 
      df$statistic == "est_sd","avg"])
  sd_grp_2 <- mean(df[df$group == 2 & df$type == "raw" & 
      df$statistic == "est_sd","avg"])
  sd_st_grp_1 <- mean(df[df$group == 1 & df$type == "standardized" & 
      df$statistic == "est_sd","avg"])
  sd_st_grp_2 <- mean(df[df$group == 2 & df$type == "standardized" & 
      df$statistic == "est_sd","avg"])
  # rmse12 <- mean(rmse_grp_1,rmse_grp_2)
  # rmse_st12 <- mean(rmse_st_grp_1,rmse_st_grp_2)
  # mean12 <- mean(mean_grp_1,mean_grp_2)
  # mean_st12 <- mean(mean_st_grp_1,mean_st_grp_2)
  # sd12 <- mean(sd_grp_1,sd_grp_2)
  # sd_st12 <- mean(sd_st_grp_1,sd_st_grp_2)
  
  nms <- c("rmse","rmse_st","mean","mean_st","sd","sd_st")
  stat_1 <- data.frame(cbind(rmse_grp_1,rmse_st_grp_1,mean_grp_1,mean_st_grp_1,
      sd_grp_1,sd_st_grp_1))
  names(stat_1) <- nms
  stat_1$group <- 1
  stat_2 <- data.frame(cbind(rmse_grp_2,rmse_st_grp_2,mean_grp_2,mean_st_grp_2,
      sd_grp_2,sd_st_grp_2))
  names(stat_2) <- nms
  stat_2$group <- 2
  stat_12 <- data.frame(cbind(mean(c(rmse_grp_1,rmse_grp_2)),
        mean(c(rmse_st_grp_1,rmse_st_grp_2)),
        mean(c(mean_grp_1,mean_grp_2)),
        mean(c(mean_st_grp_1,mean_st_grp_2)),
        mean(c(sd_grp_1,sd_grp_2)),
        mean(c(sd_st_grp_1,sd_st_grp_2))))
  names(stat_12) <- nms
  stat_12$group <- 0
  
  stat <- rbind(stat_1,stat_2,stat_12)
  stat$group <- factor(stat$group,levels=c(0,1,2),
    labels=c("Combined","Group 1","Group 2"))
  return(stat)
}

